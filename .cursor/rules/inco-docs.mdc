---
description: 
globs: 
alwaysApply: true
---
# Inco Internship Assignment: Millionaire‚Äôs Dilemma : Yacht Edition üö§

Alice, Bob, and Eve are millionaires who want to figure out who's the richest without revealing their wealth to each other or anyone else. Your mission is to build a confidential smart contract and front-end using Inco Lightning that settles this question once and for all, privately and securely.

## Your task is to:
- Help Alice, Bob, and Eve compare their private balances without revealing them to anyone (not even each other). Make sure that nobody is able to learn the secrets by exploiting the smart contract.
- Determine and reveal only the richest person among the three.
- Build this using Inco Lightning's `euint256` and `ebool` encrypted types.
- Implement both the smart contract and a basic frontend for submission.
- Ensure all testing is done locally using Inco Lightning Rod, as explained in the docs.inco.org.
- Use the official Inco Lightning template and next Js kit
- Frontend should demonstrate the full private comparison flow (Optional)
- The solution must be production-grade, cleanly structured, and well-documented

## Objective: to allow Alice, Bob, and Eve to:
- Privately submit their wealth
- Compare against each other without revealing values
- Reveal only the richest participant

## Roles: There are two roles you can apply for:

### 1. Smart Contract Engineer
- Focus on clean, secure, and scalable smart contract logic
- You must still provide a minimal frontend to demonstrate the flow
- Ideal if you're strong in Solidity and Inco Lightning, but not a frontend expert

### 2. Full Stack Engineer
- Build both smart contract + a well-designed frontend
- The frontend should allow Alice, Bob, and Eve to:
  - Privately submit encrypted values
  - View comparison results via re-encryption and decryption
  - Provide a smooth, intuitive UI experience

Introduction
Welcome to Inco!

Inco Lightning is currently available on Base Sepolia in beta testnet. We are actively working on making Inco Lightning available to other chains.

Inco (short for ‚Äúincognito‚Äù) is the confidentiality layer for existing blockchains and has two core protocols: Inco Lightning and Inco Atlas.

‚Äã
What is Inco Lightning?
Inco Lightning uses Trusted Execution Environments (TEEs) to deliver verifiable confidential compute at lightning-fast speeds. It introduces new private data types, operations, and access controls, enabling smart contracts to process sensitive data securely. No new chain, no new wallet. Just import our Solidity library and start building privacy-preserving dApps today.

‚Äã
What is Inco Atlas?
Inco Atlas is powered by Fully Homomorphic Encryption (FHE) and Multi-Party Computation (MPC), and will be released in the near future.

Quickstart
Get started with Inco Lightning in minutes

‚Äã
Prerequisites
Before you begin, make sure you have:

Bun installed (you can also chose to use node + npm or equivalent)
Docker installed
Foundry installed

Basic knowledge of Solidity and JavaScript/TypeScript
‚Äã
1-minute setup

We recommend getting started using our template.

Clone the repository:

```bash
git clone git@github.com:Inco-fhevm/lightning-rod.git
cd lightning-rod
```

Note that you can also clone the repository using HTTPS:

```bash
git clone https://github.com/Inco-fhevm/lightning-rod
cd lightning-rod
```

Install dependencies:

```bash
bun install
```

Compile contracts and test:

```bash
bun run test
```

Finally, stop the docker containers which were started for the test:

```bash
docker compose down
```

Concepts Guide Introduction
Walkthrough all the concepts you need to know to get started with Inco

‚Äã
Welcome
This guide will get you up to speed on all the concepts you need to know to develop your first confidential dapp. Throughout this guide, we will be using several examples, the most common one being a confidential token. A confidential token behaves similarly to a regular ERC20 token, but the balances of the holders, and transfer amounts are hidden from the public.

Here is the full code of a simple confidential token contract:


```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8;

import {euint256, ebool, e} from "@inco/lightning/Lib.sol";

contract SimpleConfidentialToken {
    using e for *;

    mapping(address => euint256) public balanceOf;

    constructor() {
        balanceOf[msg.sender] = uint256(1000 * 1e9).asEuint256();
    }

    function transfer(
        address to,
        bytes memory valueInput
    ) external returns (ebool) {
        euint256 value = valueInput.newEuint256(msg.sender);
        return _transfer(to, value);
    }

    function transfer(
        address to,
        euint256 value
    ) public returns (ebool success) {
        require(
            msg.sender.isAllowed(value),
            "SimpleConfidentialToken: unauthorized value handle access"
        );

        return _transfer(to, value);
    }

    function _transfer(
        address to,
        euint256 value
    ) external returns (ebool success) {
        success = balanceOf[msg.sender].ge(value);
        euint256 transferredValue = success.select(
            value,
            uint256(0).asEuint256()
        );

        euint256 senderNewBalance = balanceOf[msg.sender].sub(transferredValue);
        euint256 receiverNewBalance = balanceOf[to].add(transferredValue);

        balanceOf[msg.sender] = senderNewBalance;
        balanceOf[to] = receiverNewBalance;

        senderNewBalance.allow(msg.sender);
        receiverNewBalance.allow(to);
        senderNewBalance.allowThis();
        receiverNewBalance.allowThis();
    }
}
```

Continue this guide to understand how this code works and its concepts.

Handles
Unique Identifier for an immutable piece of hidden data

‚Äã
E-Types
At the top of the confidential token implementation, we can see that we are importing new types of variables:


Copy
import {euint256, ebool, e} from "@inco/lightning/Lib.sol";
euint256 and ebool are the hidden counterparts of uint256 and bool, respectively. They are used to represent hidden values in the contract. The e- types are the hidden counterparts of the standard types in Solidity.

In our token example, the user balances are notably represented as euint256:


```solidity
mapping(address => euint256) public balanceOf;
```
If we look into Inco‚Äôs library, we can see how euint256 and ebool are defined:


```solidity
type euint256 is bytes32;
type ebool is bytes32;
```
If we try looking up on a block explorer the raw value returned by calling balanceOf, we will get something like:


```solidity
0xa8d84064218bfc979af10dccc8153c9ab8a15068c3d64cb63927aca8ad1a3c9c
```
This gibberish value gives us no information about the actual balance of the user.

‚Äã
What is a Handle?
A handle is a unique identifier for an immutable piece of hidden data. In our token example, the balance of each user is represented as a handle, ebool success, euint256 value, etc. are also handles. The onchain smart contract is manipulating identifiers for a piece of hidden data (a balance, a boolean, etc.), and the actual data is safely stored offchain in an encrypted manner. Whenever an operation is performed over encrypted data types, the result is also a handle, like so:


```solidity
euint256 senderNewBalance = balanceOf[msg.sender].sub(transferredValue);
```
A handle is immutable. If we were to reassigning a variable like so:


```solidity
balanceOf[msg.sender] = balanceOf[msg.sender].sub(transferredValue);
```
`balanceOf[msg.sender]` would get assigned a new handle. It is important to keep in mind that the handle representing the old balance still exists, and still corresponds to the encrypted value of the old balance, even if the contract is not keeping track of it. We will see later in this guide that the value of handles are never lost and can still be accessed. From Inco‚Äôs standpoint, handles get created but never deleted.

Inputs
How to input external values and convert them to handles

‚Äã
Case 1: the value comes from an offchain source
In the confidential transfer example, the first external method is meant to be called by an EOA / Smart account. It is using newEuint256 to convert the input value into a handle.

```solidity
function transfer(
        address to,
        bytes memory valueInput
    ) external returns (ebool) {
        euint256 value = valueInput.newEuint256(msg.sender);
        // stuff
    }
```

newEuint256 takes two arguments, the encrypted input value (in the form of bytes) and the address of the account doing the input (here msg.sender). This account should always be the one that created the input, it will be given decryption right over the handle. Passing another address than the user doing the input would be a malicious implementation.

valueInput has to be a ciphertext, meaning it has to be the value intended to be transferred, encrypted in a way that Inco can understand. To do this, you can use the encrypt method from the JavaScript SDK.

If the bytes memory valueInput is malformed, Inco will fallback to the handle default value. The default value of euint256 is 0, and the default value of ebool is false.

After newEuint256 has been used, the resulting handle can be used immediately, there is no need for Inco to issue a confirmation to start using it in the contract logic. Inco will decrypt the corresponding ciphertext safely inside its TEE after the transaction has been included onchain. All operations onchain are performed virtually over identifiers, and reproduced over the actual values by Inco asynchronously. We call this model ‚Äúsymbolic execution‚Äù.

One could try to reuse the same ciphertext as another user to gain decryption access over it. Our JS SDK embeds context information in the ciphertext (originating account, chain, contract), and the value of the created handle will fallback to the default if it is used in another context.

‚Äã
Case 2 : the value comes from a variable
A known value can be turned into a handle using the asEuint256 method. This is sometimes called performing a ‚Äútrivial encrypt‚Äù because the resulting handle will be of a known value. We can see it in the constructor of the token example:


```solidity
constructor() {
    balanceOf[msg.sender] = uint256(1000 * 1e9).asEuint256();
}
```

Anyone can see that the initial value of balanceOf[msg.sender] is 1000 * 1e9, but after the deployer sends a few transfers, its balance will be unknown to the public.

Operations
Compute over private state

Inco exposes mathematical and logical operations over encrypted data. Note that for each operation that takes 2 arguments (i.e binary types below), you can use either an e-type or a regular variable as the first or second argument. Each operation returns a single e-type as result.

Under the hood, all operations are performing a call to the Inco contract singleton. The Inco contract checks access control rules and emits an event for each operation

‚Äã
Example usage

```solidity
euint256 a = e.asEuint256(2);
euint256 b = e.asEuint256(3);
euint256 c = a.add(b); // c = 5 (encrypted)
```
‚Äã
Here's the content in Markdown format:

```markdown
## Supported math operations
All these operations return an `euint256`.

| Name          | Function | Type    |
|---------------|----------|---------|
| Addition      | `e.add`  | Binary  |
| Subtraction   | `e.sub`  | Binary  |
| Multiplication| `e.mul`  | Binary  |
| Division      | `e.div`  | Binary  |
| Remainder     | `e.rem`  | Binary  |
| BitAnd        | `e.and`  | Binary  |
| BitOr         | `e.or`   | Binary  |
| BitXor        | `e.xor`  | Binary  |
| Shift Right   | `e.shr`  | Binary  |
| Shift Left    | `e.shl`  | Binary  |
| Rotate Right  | `e.rotr` | Binary  |
| Rotate Left   | `e.rotl` | Binary  |

## Supported comparison operations

| Name                   | Function | Type    | Returns     |
|------------------------|----------|---------|-------------|
| Equal                  | `e.eq`   | Binary  | `ebool`     |
| Not equal              | `e.ne`   | Binary  | `ebool`     |
| Greater than or equal  | `e.ge`   | Binary  | `ebool`     |
| Greater than           | `e.gt`   | Binary  | `ebool`     |
| Less than or equal     | `e.le`   | Binary  | `ebool`     |
| Less than              | `e.lt`   | Binary  | `ebool`     |
| Min                    | `e.min`  | Binary  | `euint256`  |
| Max                    | `e.max`  | Binary  | `euint256`  |
| Not                    | `e.not`  | Unary   | `ebool`     |
```

Control Flow
Using select and the multiplexer design pattern

Since Inco enables smart contracts to compute over private data without leaking any information, two common programming usages can‚Äôt be used.

You can‚Äôt use an if/else statement with a condition depending on a private value. The flow that the program would take would leak information about the private value.

For the same reason you can‚Äôt revert a transaction based on a condition depending on a private value.

To go around this, we use a pattern called the multiplexer design pattern.

‚Äã
Multiplexer Design Pattern
The inco equivalent of an if/else statement is the select statement. The select statement takes an encrypted boolean as first argument and two encrypted values as second and third arguments. The result of the select statement is the second argument if the first argument is true and the third argument otherwise.

Example usage from the confidential token contract:

```solidity
function _transfer(address to, euint256 value) internal returns (ebool success) {
    // we check that the user has enough balance, and assign the result to the ebool success
    success = balanceOf[msg.sender].ge(value);
    // we use the select statement to assign the value to be transferred
    // if the the user has enough balance, we transfer the value
    // otherwise we assign 0 to the transferred value
    euint256 transferredValue = success.select(value, uint256(0).asEuint256());
    // ... rest of the transfer logic
}
```

In the confidential token example, instead of reverting if the user has insufficient balance, we transfer an amount of 0, which is equivalent to doing nothing. Expect this kind of logic in most confidential apps.

Access Control
Fully programmable access control over encrypted data

The access control logic is fully programmable and onchain. Who has the right to decrypt and see a give ciphertext is visible onchain.

To give access to an account (i.e an address) to a ciphertext, you can use the e.allow function. This will grant the address permanent access to seeing, publicly decrypting and computing over the ciphertext.

Since handles are immutable, sharing access to a variable to an account only grants access to the current value of the variable. Whenever the variable is updated, the handle changes and the access to the new handle must be granted again. For example, ou can share your current balance with an address, but if you update your balance, the address will not be able to see the new value.

Example usage from the confidential token contract:


```solidity
function _transfer(address to, euint256 value) internal returns (ebool success) {
    // ... some previous logic
    // allow the sender to see its new balance
    senderNewBalance.allow(msg.sender);
    // allow the receiver to see its new balance
    receiverNewBalance.allow(to);
    // allow this contract to be able to compute over the new balances in future transfers
    senderNewBalance.allowThis();
    receiverNewBalance.allowThis();
    // let the caller know if the transfer was successful
    success.allow(msg.sender);
}
e.allowThis(value) is an alias for e.allow(value, address(this)).
```

A common mistake is to forget to call allowThis on a variable after updating it. This will result in the contract being unable to compute over the variable in future transactions.

Always call e.allowThis after updating a variable, if this variable will be used in your contract again.

‚Äã
Transient Allowance
e.transientAllow is not yet available in the SDK, but coming very soon.

A transient allowance is an allowance that is valid only for the current transaction. All results of operations such as e.add are transiently allowed to be decrypted by the contract who called the operation. That is why contracts can perform back to back operations using results of previous operations. But since this allowance is transient, calling e.allowThis is necessary to allow the contract to compute over the result in future transactions.

‚Äã
How to reason about access
The correct way to think of access control is to consider that each account (i.e any address of EOA/contract/smart wallet) that received access to a ciphertext at some point, either transiently or permanently, knows its value, has stored it, and may compute over it. Note that once the access over a ciphertext is shared, the receiving account may share it with any other account, or publicly decrypt it. Be very mindful of the access you grant over your ciphertexts in your apps, and don‚Äôt consider transient allowances to be ‚Äúsafer‚Äù in any way than permanent ones.

Decryption
Decrypt info in your smart contract

Smart contracts can trigger a public decryption of any ciphertext it has access to. This flow is asynchronous, the contract issues a request first and receives the decryption result in a callback function in a later block.

Inco will try calling the callback function once and won‚Äôt retry if it reverts.

Lets consider the following example where the sender of a confidential transfer decrypts if it has been successful:


```solidity
function doATransfer() public {
    ebool success = token.transfer(bob, amount);
    // the third argument is arbitrary data that will be passed to the callback function
    success.requestDecryption(this.toCallback.selector, "");
}

function toCallback(
    uint256 /* requestId */, // unique id of the request, useful to track multiple requests
    bool result,
    bytes memory /* data */ // arbitrary data passed to the callback
) external {
    if (result) {
        // it worked !
    }
}
```
The callback will always expect these three arguments:

requestId: the unique id of the request, useful to track multiple requests
result: the result of the decryption (bool or uint256)
data: the arbitrary data passed to the callback
e.requestDecryption returns a unique id for the request, which can be used to track multiple requests. It can be called over an ebool or an euint256 that the contract has access to.

Signature of the e.requestDecryption function:

```solidity
function requestDecryption(
    ebool a,
    bytes4 callbackSelector,
    bytes memory callbackData
) returns (uint256 requestId);

function requestDecryption(
    euint256 a, 
    bytes4 callbackSelector, 
    bytes memory callbackData
) returns (uint256 requestId);
```

Reencryption
Reencryption allows the user to access their own private data without it being exposed to anyone else.

The decryption of a ciphertext described in the previous page is triggered by an on-chain smart contract, and will expose the underlying plaintext to the public. For some use cases, for example accessing your private confidential token balance, a public decryption is not desired.

Reencryption comes in to play when a user wants to access their own private data without revealing it to any other third party.

‚Äã
How it Works
The idea behind reencryption is that the user generates on the client-side an ephemeral private/public keypair. The user will then ask the covalidator to decrypt an on-chain handle, and immediately reencrypt the plaintext using the user‚Äôs generated public key. This way, only the user can decrypt the reencrypted ciphertext using the ephemeral private key.

A sequence diagram of the reencryption flow can be found in the Decryption Mechanisms page.

‚Äã
Access Control
Access control is of particular importance in the reencrypt flow. A reencrypt request is valid only if the two following conditions are met:

the user requesting a reencryption must have access to the handle. This on-chain validation prevents other people seeing your own private data, and vice-versa.
the user requesting a reencryption must sign an EIP-712 message over the ephemeral public key they generated, using the same address that has access to the handle. This ensures that it‚Äôs indeed the user that requested a reencryption to that ephemeral public key, and not some malicious actor.
‚Äã
Requesting a Reencryption
A reencryption does not require any on-chain transaction. On the contract side, we simply require that the handle is publicly readable. For example, for a confidential token contract, the mapping of user address to confidential balance can be made public.

Once the handle to be reencrypted is retrieved on the client side, we can use the JS SDK‚Äôs reencryptor to request a reencryption. The SDK will perform all the low-level steps, such as generating an ephemeral keypair and signing the EIP-712 message, and will return the plaintext value.

Best Practices
Avoid pitfalls and write secure dapps

To close this concepts guide, here are some best practices to keep in mind when creating your confidential dapps.

‚Äã
Always check allowance over inputs
As we have seen in the confidential token example, most of your external facing functions that expose a confidential input will want to be declared twice like so.


```solidity
function transfer(address to, bytes memory valueInput) external returns (ebool) {
    euint256 value = valueInput.newEuint256(msg.sender);
    return _transfer(to, value);
}

function transfer(address to, euint256 value) public returns (ebool success) {
    require(msg.sender.isAllowed(value), "SimpleConfidentialToken: unauthorized value handle access");
    return _transfer(to, value);
}
```

This is because one function is meant to receive a ciphertext created offchain, and the other is meant to be called by smart contracts sending an existing e-variable. In the second function, you should always check that the caller has access to the ciphertext handle that is passed as an argument. This is done by performing a require over msg.sender.isAllowed(value). This is important because the caller may use an existing handle that it has not access to but that the contract has access to. In this case, depending on the contract, the caller may be to deduce or gain access to the value in used as input.

‚Äã
Think in terms of information leakage
When designing an app, you need to be mindful not only to who receives access over the ciphertexts, but also about what can be deduced from the information that is publicly available.

For example, if we were to naively port Uniswap pools to Inco, we may want to accept confidential input amounts for a swap and send confidential output amounts. If the price of the pool is public, then the swapped amount can be deduced by comparing the price before and after the swap.

In another example, if you are holding a secret auction where the current highest bidder is continuously updated, one can deduce the current highest bid by submitting increasingly large bids until it becomes the highest bidder.

This kind of possible deductions are called information leakage, and may show up often in your dapps.

‚Äã
Don‚Äôt lose access over your ciphertexts
Don‚Äôt forget to call e.allowThis() and e.allow after an operation. By default, after the transaction is included, no one retains access to the new handles being created and the contract will not be able to compute over them in the future, and the user won‚Äôt be able to see them if not granted access.

‚Äã
Be extra careful of delegatecalls
A contract being delegatecalled can decrypt any ciphertext your contract holds or share access to it.

Don‚Äôt hesitate to contact us for any question or if you want to discuss your dapp design. We are also interested in your feedback on this doc.

Overview
Inco is a confidentiality layer for blockchains that enables privacy-preserving smart contracts without modifying the underlying blockchain. Unlike monolithic privacy solutions, Inco follows a modular approach similar to how SSL/TLS provides security for internet protocols.

Whitepaper coming soon!

‚Äã
High-level Components
Inco‚Äôs architecture consists of four main components that work together to provide confidential computing capabilities:

Smart Contract Library
Confidential Compute Nodes
Decryption Nodes + Callback Relayer
Client-side JavaScript Library
These components work together to provide a seamless experience for developers building privacy-preserving applications on blockchain. The system handles encrypted data types, performs confidential computations, and manages secure decryption processes while maintaining compatibility with existing EVM blockchains.

Components
‚Äã
Smart Contract Library
The Smart Contract Library extends the EVM with encrypted data types and operations. It is deployed on the host blockchain and provides:

Encrypted data types (ebool, eaddress, estring, euint32)
Arithmetic operations (e.add, e.sub, e.mul)
Comparison operations (e.eq, e.le, e.gt)
Conditional operations (e.select)
Decryption operations (e.asyncDecrypt)
This library allows developers to write smart contracts that handle encrypted data without modifying the underlying blockchain.

‚Äã
Confidential Compute Nodes
The confidential compute nodes run in Trusted Execution Environments (TEEs) and execute confidential computations. Each compute node:

Runs the Inco computation binary in a secure enclave
Processes encrypted operations based on blockchain events
Validates access control before decryption
‚Äã
Decryption Nodes + Callback Relayer
Multiple decryption nodes operate in a quorum of TEEs to ensure security and reliability.

This is how a ciphertext can be converted into plaintext, and settled back onchain:

Monitors blockchain for decryption requests
Forwards decryption requests to the decryption network (TEEs)
Collects signed results from the decryption network
Submits decryption results back to the blockchain via callback transactions
The signed results are verified on the host chain to ensure that the decryption attestations are coming from the trusted set of decryption nodes.

‚Äã
Client-side JavaScript Library
The JavaScript Library provides client-side functionality for interacting with the host chain and Inco:

Encrypts user inputs using the network‚Äôs public key
Handles ephemeral key and EIP-712 signature generation for reencryption requests
Decrypts results locally for the user

Decryption mechanisms
Inco provides two types of decryption mechanisms:

Re-encryption for decryption and viewing privately
Onchain Decryption for decrypting a ciphertext and revealing to the entire network
‚Äã
Re-encryption (View)
Used when a user wants to view their confidential data:

1. User signs an EIP-712 message proving ownership of their wallet
2. Client generates an ephemeral keypair
3. User sends decryption request with signed message and ephemeral public key
4. The decryption node verifies the signature and checks access control
5. The decryption node re-encrypts the data with the user‚Äôs ephemeral public key so that there‚Äôs no information leakage in transit
6. User decrypts the result with ephemeral private ke

Onchain Decryption (Public Reveal)
Used when the result needs to be made available on-chain:

1. Smart contract calls e.asyncDecrypt(encryptedValue)
2. The decryption network monitors for decryption events
3. The decryption network query the ACL to verify permissions
4. Each decryption network node decrypts the value and sign the result
5. Relayer collects signatures and submits a callback to the contract
6. Smart contract verifies the signatures and uses the decrypted value

Solidity SDK
Build confidential smart contracts with Inco Solidity SDK

‚Äã
Overview
The Inco Solidity SDK provides tools to locally develop and test confidential smart contracts.

We recommend using our template which uses Foundry solidity-based testing.

HardHat js-based testing is also supported. If you are not familiar with Inco, we recommend starting with our concepts guide.

Library Reference
All functions exposed by the Inco library

‚Äã
Types
ebool: Encrypted bool
euint256: Encrypted uint256
‚Äã
## Math Operations
All these operations return an `euint256`. All binary operations may use either an `euint256` or a regular `uint256` as the first or second argument, or two `euint256`s.

| Name            | Function | Type    |
|-----------------|----------|---------|
| Addition        | `e.add`  | Binary  |
| Subtraction     | `e.sub`  | Binary  |
| Multiplication  | `e.mul`  | Binary  |
| Division        | `e.div`  | Binary  |
| Remainder       | `e.rem`  | Binary  |
| BitAnd          | `e.and`  | Binary  |
| BitOr           | `e.or`   | Binary  |
| BitXor          | `e.xor`  | Binary  |
| Shift Right     | `e.shr`  | Binary  |
| Shift Left      | `e.shl`  | Binary  |
| Rotate Right    | `e.rotr` | Binary  |
| Rotate Left     | `e.rotl` | Binary  |

## Comparison Operations

| Name                   | Function | Type    | Returns     |
|------------------------|----------|---------|-------------|
| Equal                  | `e.eq`   | Binary  | `ebool`     |
| Not equal              | `e.ne`   | Binary  | `ebool`     |
| Greater than or equal  | `e.ge`   | Binary  | `ebool`     |
| Greater than           | `e.gt`   | Binary  | `ebool`     |
| Less than or equal     | `e.le`   | Binary  | `ebool`     |
| Less than              | `e.lt`   | Binary  | `ebool`     |
| Min                    | `e.min`  | Binary  | `euint256`  |
| Max                    | `e.max`  | Binary  | `euint256`  |
| Not                    | `e.not`  | Unary   | `ebool`     |

Multiplexer
e.select(ebool, euint256, euint256) returns(euint256): Select between two euint256s based on an ebool condition
e.select(ebool, ebool, ebool) returns(ebool): Select between two ebools on the first ebool condition
‚Äã
Inputs
e.asEuint256(uint256) returns(euint256): Convert a uint256 to an euint256 (trivial encrypt)
e.asEbool(bool) returns(ebool): Convert a bool to an ebool (trivial encrypt)
e.newEuint256(bytes memory input) returns(euint256): Create a new euint256 from a ciphertext
e.newEbool(bytes memory input) returns(ebool): Create a new ebool from a ciphertext
‚Äã
Access control
e.allow(address): Allow a user to access the value permanently
e.allowThis() : Allow the current contract to access the value permanently
e.isAllowed(address, e-value) returns(bool) : Check if a user is allowed to access the value (transient or permanent)
‚Äã
Decryption request
e.requestDecryption(euint256 value, bytes4 callbackSelector, bytes memory callbackData) returns (uint256 requestId): Request decryption of an euint256
e.requestDecryption(ebool value, bytes4 callbackSelector, bytes memory callbackData) returns (uint256 requestId): Request decryption of an ebool
‚Äã
Decryption callback format

```solidity
function callback(
        uint256 requestId,
        uint256 result,
        bytes memory data
    ) external {
        // code
    }
```

Cheatcodes reference
Fully simulate the Inco environment all from solidity tests

‚Äã
Execute the operations
Inco‚Äôs infrastructure is monitoring the operations requested over encrypted variables by the smart contracts.
Inco executes them asynchronously after the blocks containing the ops are mined. Under the hood, the Inco singleton instance on each supported chain is emitting events to request the operations (that includes encrypts, trivial encrypts, all logical and mathematical operations, and decryption requests). The solidity-based mock is using Foundry‚Äôs vm.recordLogs() function to record the pending ops.
As the events recording are consumed whenever read, there would be conflicts if you try to use recordLogs in your tests.
To simulate Inco processing the operations, which assigns to its internal value store its encrypted value to each handle, use the following cheatcode:


Copy
processAllOperations();
This cheatcode must be called before reading the value of any encrypted variable, and performing assert statements. processAllOperations also executes any pending decryption callback.

‚Äã
Simulate Inputs
Encrypted inputs are normally generated using Inco‚Äôs JS SDK. Simulate them with the following cheatcodes:

‚Äã
For euint256

```solidity
fakePrepareEuint256Ciphertext(uint256 value) returns (bytes memory ciphertext);

// example usage
token.transfer(bob, fakePrepareEuint256Ciphertext(1 ether));
```
‚Äã
For ebool

```solidity
fakePrepareEboolCiphertext(bool value) returns (bytes memory ciphertext);

// example usage
someContract.setActive(fakePrepareEboolCiphertext(true));
```
‚Äã
Simulate decryption
Allowed accounts can request reading the values of e-variables using JS SDK. In the tests, you can read any value bypassing the access control checks.

‚Äã
For euint256

```solidity
getUint256Value(euint256 input) (uint256);

// example usage
assertEq(getUint256Value(token.balanceOf(alice)), 9 * GWEI);
```

Build a Confidential Token
This tutorial will guide you through creating and deploying a confidential fungible token. You can choose your preferred development environment

## Foundry Guide

Setup
Setup your repo

‚Äã
Using the lightning-rod template (recommended)
We recommend using our template which comes with foundry already setup.


```bash
git clone git@github.com:Inco-fhevm/lightning-rod.git
cd lightning-rod
bun install
```
Using the template, you may want to skip to the cheatcodes reference.

‚Äã
Or setup manually
You do not need to follow these steps if you are using the lightning-rod template.

Follow these steps to add inco to your existing project, or manually setup a new one.

‚Äã
Download the inco libraries
Inco uses npm packages to provide its solidity library.


```bash
bun add @inco/lightning @inco/shared
```
Alternatively, you can use npm/yarn/pnpm.

‚Äã
Setup remappings
Create a file remappings.txt at the root of your contracts directory.


```bash
touch remappings.txt
```
Edit your remappings paths according to your setup.


```
forge-std/=your/path/to/forge-std/src/
ds-test/=your/path/to/ds-test/src/
@inco/=path/to/your/node_modules/@inco/
@openzeppelin/=path/to/your/node_modules/@openzeppelin/
```

Due to how solidity imports and remappings work, your remappings have to follow the idiomatic form. Here are the requirements so your project compiles while using inco:

left to the = sign, have the following names

forge-std/
ds-test/
@inco/
@openzeppelin/
right to the = sign, have the path to the corresponding library
forge-std/ should point to the src/ directory of your local forge-std library
ds-test/ should point to the src/ directory of your local ds-test library
@inco/ should point to the @inco directory in your node_modules directory, and not to the @inco/lightning or @inco/shared directories
In the same way @openzeppelin/ should point to the @openzeppelin directory in your node_modules directory
To simplify this process, we recommend using bun/npm to import all the dependencies (including foundry-std and ds-test) like so:


```bash
bun add  @inco/lightning @inco/shared https://github.com/dapphub/ds-test https://github.com/foundry-rs/forge-std @openzeppelin/contracts
```

and using this remapping file (supposing that your node_modules sit one directory up from your contracts directory):


```
@openzeppelin/=../node_modules/@openzeppelin/
forge-std/=../node_modules/forge-std/src/
ds-test/=../node_modules/ds-test/src/
@inco/=../node_modules/@inco/
```

Foundry Guide
Import Inco in your contract
Use the Inco library to enable confidentiality in your contract

To start using Inco features in your contract, all you need is to add this line at the top of your solidity file:


Copy
import {e, ebool, euint256} "@inco/lightning/src/Lib.sol";
and add this line at the top of the contract body:


Copy
using e for *;
Now you have access to encrypted types and operations in your contract. Here is a full example of a simple fungible token:

The following example is present with comments explaining the code here in the lightning-rod template.


```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8;

import {euint256, ebool, e} from "@inco/lightning/Lib.sol";

contract SimpleConfidentialToken {
    using e for *;

    mapping(address => euint256) public balanceOf;

    constructor() {
        balanceOf[msg.sender] = uint256(1000 * 1e9).asEuint256();
    }

    function transfer(
        address to,
        bytes memory valueInput
    ) external returns (ebool) {
        euint256 value = valueInput.newEuint256(msg.sender);
        return _transfer(to, value);
    }

    function transfer(
        address to,
        euint256 value
    ) public returns (ebool success) {
        require(
            msg.sender.isAllowed(value),
            "SimpleConfidentialToken: unauthorized value handle access"
        );

        return _transfer(to, value);
    }

    function _transfer(
        address to,
        euint256 value
    ) external returns (ebool success) {
        success = balanceOf[msg.sender].ge(value);
        euint256 transferredValue = success.select(
            value,
            uint256(0).asEuint256()
        );

        euint256 senderNewBalance = balanceOf[msg.sender].sub(transferredValue);
        euint256 receiverNewBalance = balanceOf[to].add(transferredValue);

        balanceOf[msg.sender] = senderNewBalance;
        balanceOf[to] = receiverNewBalance;

        senderNewBalance.allow(msg.sender);
        receiverNewBalance.allow(to);
        senderNewBalance.allowThis();
        receiverNewBalance.allowThis();
    }
}
```

This contract is explained in depth in the Concepts Guide.

Foundry Guide
Test your contract
Test your contract in solidity, using Inco cheatcodes

In the package that comes the Inco library, an extension to the usual Test Foundry contract is provided.
You can import it like this:


Copy
// SPDX-License-Identifier: MIT
pragma solidity ^0.8;

import {IncoTest} from "@inco/lightning/src/test/IncoTest.sol";

contract YourTest is IncoTest {
    function testSomething() public {
        // Your test code here
    }
}
IncoTest extends Foundry‚Äôs Test contract, and exposes useful Inco-specific cheatcodes to test your contract.
If you are extending the setUp function, remember to call super.setUp() at the beginning of your function.

‚Äã
Example
The following example is present with comments explaining the code here in the lightning-rod template.


```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8;

import {SimpleConfidentialToken} from "../SimpleConfidentialToken.sol";
import {IncoTest} from "@inco/lightning/src/test/IncoTest.sol";
import {GWEI} from "@inco/shared/src/TypeUtils.sol";

contract TestSimpleConfidentialToken is IncoTest {
    SimpleConfidentialToken token;

    function setUp() public override {
        super.setUp();
        token = new SimpleConfidentialToken();
        token.transfer(alice, fakePrepareEuint256Ciphertext(10 * GWEI));
    }

    function testTransfer() public {
        vm.prank(alice);
        token.transfer(bob, fakePrepareEuint256Ciphertext(1 * GWEI));
        processAllOperations();
        uint256 decryptedBobBalance = getUint256Value(token.balanceOf(bob));
        uint256 decryptedAliceBalance = getUint256Value(token.balanceOf(alice));
        assertEq(decryptedBobBalance, 1 * GWEI);
        assertEq(decryptedAliceBalance, 9 * GWEI);
    }
}
```

Once you are happy with the state of your contract, you can deploy it as-is without any changes and Inco will react to its ops (as long as you are on a supported network, currently only Base-Sepolia).

Read on for the reference of the available cheatcodes.

## Hardhat Guide

Setting up Environment for Hardhat
This is a quick start guide for deploying and understanding a confidential ERC20 using the Hardhat template.

1
Prerequisites

We recommend installing nvm (Node Version Manager) first and then install Node.js with nvm.

For Linux: The official Linux version can be found here or follow this tutorial.
For Windows, follow the Readme guide.
For Mac, you can follow this tutorial.
Install Node.js:


```bash
nvm install node
```

Install pnpm:


```bash
npm install -g pnpm
```

2
Setting up your environment

Clone the template project:

```bash
git clone https://github.com/Inco-fhevm/inco-lite-template.git
cd inco-lite-template
```

Install dependencies:

```
pnpm install
Set up .env file. You can use the values below, taken from the README:

# This should be a private key funded with native tokens.
PRIVATE_KEY_ANVIL="0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80"
PRIVATE_KEY_BASE_SEPOLIA=""

# This should be a seed phrase used to test functionalities with different accounts.  
# You can send funds from the main wallet to this whenever needed.
SEED_PHRASE="garden cage click scene crystal fat message twice rubber club choice cool"

# This should be an RPC URL provided by a proper provider  
# that supports the eth_getLogs() and eth_getFilteredLogs() methods.
LOCAL_CHAIN_RPC_URL="http://localhost:8545"
BASE_SEPOLIA_RPC_URL="https://base-sepolia-rpc.publicnode.com"
```

If you don‚Äôt have a mnemonic, you can generate one using this website or use our default test accounts. We recommend using RPC providers instead of public endpoints for better log access.


Compile contracts:

```bash
pnpm hardhat compile
```

Run a local Node
The current instructions will run a local node and a local covalidator. If you are using this template against another network, e.g. Base Sepolia, skip this step.


```bash
docker compose up
```

Run tests:

```bash
pnpm hardhat test --network anvil
```

## README FOR HARDHAT REPO

# **Inco Lite - Hardhat Template**

This repository provides a **complete Hardhat setup** for testing **reencryption, decryption, and ciphertext formation** in smart contracts.

## **Setup Instructions**

Below, we run a local node and a local covalidator (taken from @the Docker Compose file), and run Hardhat tests against it.

### **1. Clone the Repository**
```sh
git clone <your-repo-url>
cd into_your_repo
```

### **2. Install Dependencies**
```sh
pnpm install
```

### **3. Run a local node**

The current instructions will run a local node and a local covalidator. If you are using this template against another network, e.g. Base Sepolia, skip this step.

```sh
docker compose up
```

### **3. Configure Environment Variables**  

Fill in your own information in the `.env` file, you can take this as example:

```plaintext
# This should be a private key funded with native tokens.
PRIVATE_KEY_ANVIL="0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80"
PRIVATE_KEY_BASE_SEPOLIA=""

# This should be a seed phrase used to test functionalities with different accounts.  
# You can send funds from the main wallet to this whenever needed.
SEED_PHRASE="garden cage click scene crystal fat message twice rubber club choice cool"

# This should be an RPC URL provided by a proper provider  
# that supports the eth_getLogs() and eth_getFilteredLogs() methods.
LOCAL_CHAIN_RPC_URL="http://localhost:8545"
BASE_SEPOLIA_RPC_URL="https://base-sepolia-rpc.publicnode.com"
```

### **4. Compile Smart Contracts**
```sh
pnpm hardhat compile
```

### **5. Run Tests**
```sh
pnpm hardhat test --network anvil
```

Or, if running against another network, e.g. Base Sepolia, run

```sh
pnpm hardhat test --network baseSepolia
```

## **Features**
- End-to-end testing of encryption, reencryption  and decryption functionalities.
- Hardhat-based test framework.
- Supports reencryption and ciphertext validation.

Understanding the Confidential ERC-20
Deep dive into the confidential token implementation

We will be creating a confidential ERC20 contract that enables:

Minting new tokens
Transferring tokens between accounts
Managing token allowances
Keeping all amounts encrypted
Owner-only access to view all balances
Optional global decryption of individual balances

Setting up the Contract
Learn how to set up the basic structure of a confidential ERC20 token

‚Äã
Import Required Libraries
First, we need to import the necessary contracts and libraries:


```solidity
pragma solidity ^0.8.24;
import "@inco/lightning/src/Lib.sol";
import "@openzeppelin/contracts/access/Ownable2Step.sol";
```
‚Äã
Contract Definition
Our confidential ERC20 contract inherits from Ownable2Step, which provides secure ownership management:


```solidity
contract ConfidentialERC20 is Ownable2Step {
    // Contract implementation will go here
}
```

The Ownable2Step contract from OpenZeppelin sets the owner in the constructor, allowing only the owner to view all users‚Äô balances.

‚Äã
State Variables
We need to define our state variables, including encrypted balances and allowances:


```solidity
uint256 public _totalSupply;
string public _name;
string public _symbol;
uint8 public constant decimals = 18;

// Mappings for balances and allowances
mapping(address => euint256) internal balances;
mapping(address => mapping(address => euint256)) internal allowances;
mapping(uint256 => address) internal requestIdToUserAddress;
```

Notice that balances and allowances use the euint256 type for encrypted storage.

‚Äã
Events
Define the standard ERC20 events plus our custom decryption event:


```solidity
// Events for Transfer, Approval, Mint, and Decryption
event Transfer(address indexed from, address indexed to);
event Approval(address indexed owner, address indexed spender);
event Mint(address indexed to, uint256 amount);
event UserBalanceDecrypted(address indexed user, uint256 decryptedAmount);
```
‚Äã
Understanding the Structure
Encrypted Types
euint256 is used for encrypted integers, ensuring balance privacy

Access Control
Ownable2Step provides secure ownership management

Events
Events enable tracking transfers and approvals without revealing amounts

‚Äã
Next Steps
Continue to learn how to implement the core token functionality

Contract Functions
Understanding the core functionality of the confidential token

‚Äã
Constructor
The constructor sets up the initial token configuration:


```solidity
constructor() Ownable(msg.sender) {
    _name = "Confidential USD";
    _symbol = "cUSD";
}
```
‚Äã
Minting Tokens
There are two minting functions for different use cases:


```solidity
// Standard minting with plaintext amount
function mint(uint256 mintedAmount) public virtual onlyOwner {
    balances[owner()] = e.add(
        balances[owner()],
        e.asEuint256(mintedAmount)
    );
    e.allow(balances[owner()], address(this));
    e.allow(balances[owner()], owner());
    _totalSupply += mintedAmount;
    emit Mint(owner(), mintedAmount);
}

// Minting with encrypted amount
function _mint(bytes calldata encryptedAmount) public virtual onlyOwner {
    balances[msg.sender] = e.add(
        balances[msg.sender],
        e.newEuint256(encryptedAmount, msg.sender)
    );
    e.allow(balances[msg.sender], address(this));
    e.allow(balances[msg.sender], owner());
    e.allow(balances[msg.sender], msg.sender);
}
```

The _mint function accepts encrypted amounts for enhanced privacy.

‚Äã
Transfer Functions
Two versions of transfer are available:


```solidity
// For EOAs using encrypted inputs
function transfer(
    address to,
    bytes calldata encryptedAmount
) public virtual returns (bool) {
    transfer(to, e.newEuint256(encryptedAmount, msg.sender));
    return true;
}

// For contract interactions
function transfer(
    address to,
    euint256 amount
) public virtual returns (bool) {
    ebool canTransfer = e.ge(balances[msg.sender], amount);
    _transfer(msg.sender, to, amount, canTransfer);
    return true;
}
```
‚Äã
Approval System
The approval system allows delegated spending:


```solidity
// Approve for EOAs
function approve(
    address spender,
    bytes calldata encryptedAmount
) public virtual returns (bool) {
    approve(spender, e.newEuint256(encryptedAmount, msg.sender));
    return true;
}

// Approve for contracts
function approve(
    address spender,
    euint256 amount
) public virtual returns (bool) {
    _approve(msg.sender, spender, amount);
    emit Approval(msg.sender, spender);
    return true;
}

// Internal approval logic
function _approve(
    address owner,
    address spender,
    euint256 amount
) internal virtual {
    allowances[owner][spender] = amount;
    e.allow(amount, address(this));
    e.allow(amount, owner);
    e.allow(amount, spender);
}
```
‚Äã
TransferFrom Functions
For spending approved tokens:


```solidity
// TransferFrom for EOAs
function transferFrom(
    address from,
    address to,
    bytes calldata encryptedAmount
) public virtual returns (bool) {
    transferFrom(from, to, e.newEuint256(encryptedAmount, msg.sender));
    return true;
}

// TransferFrom for contracts
function transferFrom(
    address from,
    address to,
    euint256 amount
) public virtual returns (bool) {
    ebool isTransferable = _updateAllowance(from, msg.sender, amount);
    _transfer(from, to, amount, isTransferable);
    return true;
}
```
‚Äã
View Functions
Functions to check balances and allowances:


```solidity
// Get encrypted balance
function balanceOf(address wallet) public view virtual returns (euint256) {
    return balances[wallet];
}

// Get encrypted allowance
function allowance(
    address owner,
    address spender
) public view virtual returns (euint256) {
    return _allowance(owner, spender);
}
```
‚Äã
Owner Functions
Special functions for the contract owner:


```solidity
// Request balance decryption
function requestUserBalanceDecryption(
    address user
) public onlyOwner returns (uint256) {
    euint256 encryptedBalance = balances[user];
    e.allow(encryptedBalance, address(this));

    uint256 requestId = e.requestDecryption(
        encryptedBalance,
        this.onDecryptionCallback.selector,
        ""
    );
    requestIdToUserAddress[requestId] = user;
    return requestId;
}

// Decryption callback
function onDecryptionCallback(
    uint256 requestId,
    bytes32 _decryptedAmount,
    bytes memory data
) public returns (bool) {
    address userAddress = requestIdToUserAddress[requestId];
    emit UserBalanceDecrypted(userAddress, uint256(_decryptedAmount));
    return true;
}
```
‚Äã
Next Steps
See how all these functions come together in the complete contract

Complete Contract Implementation
Full implementation of the confidential ERC20 token

Here‚Äôs the complete implementation of the confidential ERC20 token contract. You can find this code in ConfidentialERC20.sol if you‚Äôre using the Hardhat template.


```bash
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "@inco/lightning/src/Lib.sol";
import "@openzeppelin/contracts/access/Ownable2Step.sol";

contract ConfidentialERC20 is Ownable2Step {
    // Events
    event Transfer(address indexed from, address indexed to);
    event Approval(address indexed owner, address indexed spender);
    event Mint(address indexed to, uint256 amount);
    event UserBalanceDecrypted(address indexed user, uint256 decryptedAmount);

    // State variables
    uint256 public _totalSupply;
    string public _name;
    string public _symbol;
    uint8 public constant decimals = 18;

    // Encrypted state
    mapping(address => euint256) internal balances;
    mapping(address => mapping(address => euint256)) internal allowances;
    mapping(uint256 => address) internal requestIdToUserAddress;

    constructor() Ownable(msg.sender) {
        _name = "Confidential USD";
        _symbol = "cUSD";
    }

    // Minting functions
    function mint(uint256 mintedAmount) public virtual onlyOwner {
        balances[owner()] = e.add(
            balances[owner()],
            e.asEuint256(mintedAmount)
        );
        e.allow(balances[owner()], address(this));
        e.allow(balances[owner()], owner());
        _totalSupply += mintedAmount;
        emit Mint(owner(), mintedAmount);
    }

    function _mint(bytes calldata encryptedAmount) public virtual {
        balances[msg.sender] = e.add(
            balances[msg.sender],
            e.newEuint256(encryptedAmount, msg.sender)
        );
        e.allow(balances[msg.sender], address(this));
        e.allow(balances[msg.sender], owner());
        e.allow(balances[msg.sender], msg.sender);
    }

    // Transfer functions
    function transfer(
        address to,
        bytes calldata encryptedAmount
    ) public virtual returns (bool) {
        transfer(to, e.newEuint256(encryptedAmount, msg.sender));
        return true;
    }

    function transfer(
        address to,
        euint256 amount
    ) public virtual returns (bool) {
        ebool canTransfer = e.ge(balances[msg.sender], amount);
        _transfer(msg.sender, to, amount, canTransfer);
        return true;
    }

    // View functions
    function balanceOf(address wallet) public view virtual returns (euint256) {
        return balances[wallet];
    }

    // Approval functions
    function approve(
        address spender,
        bytes calldata encryptedAmount
    ) public virtual returns (bool) {
        approve(spender, e.newEuint256(encryptedAmount, msg.sender));
        return true;
    }

    function approve(
        address spender,
        euint256 amount
    ) public virtual returns (bool) {
        _approve(msg.sender, spender, amount);
        emit Approval(msg.sender, spender);
        return true;
    }

    function _approve(
        address owner,
        address spender,
        euint256 amount
    ) internal virtual {
        allowances[owner][spender] = amount;
        e.allow(amount, address(this));
        e.allow(amount, owner);
        e.allow(amount, spender);
    }

    // Allowance functions
    function allowance(
        address owner,
        address spender
    ) public view virtual returns (euint256) {
        return _allowance(owner, spender);
    }
    
    function _allowance(
        address owner,
        address spender
    ) internal view virtual returns (euint256) {
        return allowances[owner][spender];
    }

    // TransferFrom functions
    function transferFrom(
        address from,
        address to,
        bytes calldata encryptedAmount
    ) public virtual returns (bool) {
        transferFrom(from, to, e.newEuint256(encryptedAmount, msg.sender));
        return true;
    }

    function transferFrom(
        address from,
        address to,
        euint256 amount
    ) public virtual returns (bool) {
        ebool isTransferable = _updateAllowance(from, msg.sender, amount);
        _transfer(from, to, amount, isTransferable);
        return true;
    }

    // Internal helper functions
    function _updateAllowance(
        address owner,
        address spender,
        euint256 amount
    ) internal virtual returns (ebool) {
        euint256 currentAllowance = _allowance(owner, spender);
        ebool allowedTransfer = e.ge(currentAllowance, amount);
        ebool canTransfer = e.ge(balances[owner], amount);
        ebool isTransferable = e.select(
            canTransfer,
            allowedTransfer,
            e.asEbool(false)
        );
        _approve(
            owner,
            spender,
            e.select(
                isTransferable,
                e.sub(currentAllowance, amount),
                currentAllowance
            )
        );
        return isTransferable;
    }

    function _transfer(
        address from,
        address to,
        euint256 amount,
        ebool isTransferable
    ) internal virtual {
        euint256 transferValue = e.select(
            isTransferable,
            amount,
            e.asEuint256(0)
        );
        euint256 newBalanceTo = e.add(balances[to], transferValue);
        balances[to] = newBalanceTo;
        e.allow(newBalanceTo, address(this));
        e.allow(newBalanceTo, to);

        euint256 newBalanceFrom = e.sub(balances[from], transferValue);
        balances[from] = newBalanceFrom;
        e.allow(newBalanceFrom, address(this));
        e.allow(newBalanceFrom, from);

        emit Transfer(from, to);
    }
}
```
‚Äã
Contract Structure
Imports
Inco libraries for encryption
OpenZeppelin for ownership management
State
Public token details
Encrypted balances and allowances
Request tracking
Functions
Standard ERC20 interface
Encrypted variants for privacy
Internal helpers
‚Äã
Deployment
To deploy the contract using Hardhat Ignition:

Create a deployment module in ignition/modules/ConfidentialToken.ts:

```bash
import { buildModule } from "@nomicfoundation/hardhat-ignition/modules";

const ConfidentialERC20Module = buildModule("ConfidentialERC20Module", (m) => {
  const confidentialERC20Module = m.contract("ConfidentialERC20");
  return { confidentialERC20Module };
});

export default ConfidentialERC20Module;
```

Deploy using the following command:

```bash
pnpm hardhat ignition deploy ./ignition/modules/ConfidentialToken.ts --network baseSepolia
```
Run tests to verify the deployment:

```bash
pnpm hardhat test --network baseSepolia
```
The contract will be deployed with:

Name: ‚ÄúConfidential USD‚Äù
Symbol: ‚ÄúcUSD‚Äù
Decimals: 18
Owner: The deploying address (msg.sender)
Make sure to save the deployed contract address for future interactions. You‚Äôll need it when integrating with your frontend or other contracts.

Overview
JavaScript SDK
incoJs is a javascript library that enables developers to interact with the inco protocol

‚Äã
Overview
incoJs is a JavaScript library that enables developers to interact with the Inco protocol. It provides a comprehensive set of tools and utilities for building privacy-preserving decentralized applications.

‚Äã
Getting Started
There are two main ways to start using incoJs in your project:

NextJS Starter
Get started quickly with our NextJS template for building dApps with Inco

Existing Project Integration
Learn how to integrate incoJs into your existing JavaScript/TypeScript project

NextJS Starter
Get started quickly with our NextJS template for building dApps with Inco

Note: currently, the NextJS template only works against Base Sepolia. An updated template will be published shortly with a working setup against a local node and local covalidator.

‚Äã
Overview
The Inco NextJS starter template provides a pre-configured environment for building decentralized applications with privacy features. It includes everything you need to start building confidential dApps with NextJS and Inco.

‚Äã
NextJs Starter
Here‚Äôs a simple NextJs starter kit with incoJs: GitHub Template

‚Äã
Getting Started
‚Äã
1. Clone the Template
We can start by cloning our template project. You can either:

Go to our repository and click the Use this template button at the top of the page to create a new repository
Or clone it directly:

```bash
git clone https://github.com/Inco-fhevm/nextjs-template.git
cd nextjs-template
```
‚Äã
2. Install and Run
Install the project dependencies and start the development server:


```bash
npm install 
npm run dev
```

Use IncoJS in Existing Project
Integrate incoJS into your existing JavaScript/TypeScript project.

Currently only tested with Webpack and NextJS. If you are using Rollup or Vite please report any issues here
‚Äã
Install
Choose your favorite package manager:

```bash
npm install @inco/js
# or
bun install @inco/js
# or
yarn add @inco/js
```
‚Äã
Usage
A typical usage of @inco/js includes 3 steps:

Encrypting a value.
Posting the ciphertext to the contract, which will perform confidential computes on it.
Requesting a reencryption of the result of the computation.
‚Äã
1. Encrypt a value

```js
import { getViemChain, supportedChains } from '@inco/js';
import { Lightning } from '@inco/js/lite';
import { createWalletClient } from 'viem';

// Setup: do it once at initialization
const chainId = supportedChains.baseSepolia;
const zap = Lightning.latest('testnet', chainId); // Connect to Inco's latest public testnet
const walletClient = createWalletClient({
  chain: getViemChain(chainId),
  account: /* Choose your account, e.g. from window.ethereum */,
  transport: /* Choose your transport, e.g. from Alchemy */,
});
const dappAddress = '0x00000000000000000000000000000000deadbeef'; // Put your contract address here

// Encrypt the plaintext value
const plaintext = 42;
const ciphertext = await zap.encrypt(plaintext, {
  accountAddress: walletClient.account.address,
  dappAddress,
});

console.log(ciphertext); // A long hex string representing the encrypted value
```
‚Äã
2. Post the ciphertext to the contract
This step does not require any specific @inco/js functionality. We recommend using viem to interact with the blockchain. Specifically, use the writeContract method to submit transactions. Pass the ciphertext from the previous encryption step as the input ciphertext parameter of type bytes.

‚Äã
3. Request a reencryption
Following transaction submission, the Inco covalidator processes the computation request. The contract stores the computation result as a handle on-chain. This handle, referenced below as resultHandle, is a hexadecimal string of type Handle that serves as a reference to the encrypted computation output.


```js
import { Hex } from "viem";

// Request a re-encryption of the result ciphertext
const resultHandle = "0x..." as Hex; // Retrieve the handle from the contract, e.g. using viem
const reencryptor = await zap.getReencryptor(walletClient); // Use same walletClient as previous step
const resultPlaintext = await reencryptor({ handle: resultHandle });

console.log(resultPlaintext.value); // The decrypted value
```

Brand Kit
Use for creating frontends.

#1B3E86
#3673F5
#8EB1F9
#E7EEFE
#0D7534
#17D45C
#7FE8A6
#E8FCF0
